# matlab-sys
matlab-sys provides low level bindings to Matlab's C API. This allows writing [MEX functions], using the [C Matrix API], 
interacting with the [C MAT API] and authoring [Matlab Engine Applications] using Rust.  
The bindings are mostly automatically generated by bindgen and named the same or similar as in the C headers.
Some manual changes are made to the bindings to ease usage or simplify the exposed API without sacrificing
functionality, such as replacing type definitions for the fixed size integer types with the native fixed size types
from Rust.

## Usage
To make use of the functionality provided by this crate it has to be linked against the library files `libmex.lib`, 
`libmx.lib`, `libmat.lib` and `libeng.lib` provided by your installation of Matlab. If the environment variable 
`MATLABPATH` is set to the directory of the Matlab installation to link against, this path will be used preferentially. 
Otherwise the build script will attempt to seek the installation directory of the default matlab installation by running 
the following command on the build machine: `matlab -batch "disp(matlabroot)"`. This usually takes a few seconds for 
Matlab to start up, so explicitly providing the path in the aforementioned environment variable helps compile times 
and should be preferred.

### Building MEX functions directly
To build a mex function in Rust the crate type has to be a dynamic link library with a C ABI. In your `cargo.toml` 
set `crate-type = ["cdylib"]`. Every MEX function, regardless what name it will be called with from Matlab, needs an 
entry point with the following signature:
```rust
#[no_mangle]
pub unsafe extern "C" fn mexFunction(
    nlhs: c_int,
    plhs: *mut *mut mxArray,
    nrhs: c_int,
    prhs: *const *const mxArray,
)
```
Examples can be found in the [mex-examples directory](mex-examples/). These examples are direct translations of the 
original examples as distributed with Matlab in `matlabroot/extern/examples`. They are also used as tests for the 
bindings, as such they should always compile and work. After building the file extension of the build artifacts have to 
be changed to a `*.mexw64` for windows or a `*.mexa64` for linux. The filename without extension is the name of the 
function callable in Matlab. 

### Building abstractions on top of `matlab-sys`
While the ability of Rust to interact with C libraries is nice, its true power lies in building safe, ergonomic and easy 
to use abstractions. This crate in intended to work as a common building block for those abstractions in the context 
of Matlab extensions. If you happen to work on such an abstraction please let me know! I would love to know how my work 
is being used and to link to your crate.

## Features
`matlab-sys` can expose both the older C API, which still is the default when building C code with Matlab's `mex` command, 
as well as the newer C API, which you would get with `mex` and the `-R2018a` option. The newer version 
of the API changes the internal representation of some types, introduces many new functions for typed data access and
deprecates or changes the behavior of some already existing functions. Especially the first and the last point discourage mixed usage of 
both APIs. More information about the differences of the APIs can be found [here][Complex Storage Documentation].

Both versions of the API live in their own namespace, which helps prevent most accidental mixing. These namespaces 
can be enabled by their corresponding feature. Crate authors are encouraged to enable only one of both API version-features 
to prevent accidental miss-usage. That said, both features _can_ be enabled at the same time without interference, which 
satisfies [cargo's requirement for features to be purely additive][feature-unification].
### separate-complex  
This feature enables the older API version. As the name implies arrays of complex numbers are represented internally by 
separate arrays for the real and the imaginary part. This is the only available option for Matlab versions `R2017b` and prior. 
For all later releases Matlab uses a single array of interleaved real and imaginary parts for complex numbers, which 
matches most other numeric libraries. Using this API with Matlab releases after `R2017b` will incur potentially unnecessary 
copying when translation to the separate complex representation happens. In addition many new features of the newer API, 
such as typed data access, is not available.

### interleaved-complex - default 
This feature enables the newer API version, which is set to become the new default API for compilation with Matlab's `mex` command 
in the future. Arrays of complex numbers are represented internally by a single array with interleaved real and 
imaginary parts. This is the representation Matlab uses internally since release `R2018a`. As a result no copying has to 
take place at the interface. This representation is also used by most popular numeric libraries. Using this feature with 
a Matlab release older than `R2018a` will not work! For all newer releases this is the recommended API.

### link-lib - default  
This feature enables automatically linking to the necessary libraries in your Matlab installation. If you need more 
control over this process you can disable this feature by disabling the default features.


[MEX functions]: https://de.mathworks.com/help/matlab/call-mex-files-1.html
[C Matrix API]: https://de.mathworks.com/help/matlab/cc-mx-matrix-library.html
[C MAT API]: https://de.mathworks.com/help/matlab/matlab-c-api-to-read-mat-file-data.html
[Matlab Engine Applications]: https://de.mathworks.com/help/matlab/calling-matlab-engine-from-c-programs-1.html
[Complex Storage Documentation]: https://de.mathworks.com/help/matlab/matlab_external/matlab-support-for-interleaved-complex.html
[feature-unification]: https://doc.rust-lang.org/cargo/reference/features.html?highlight=additive#feature-unification
/* automatically generated by rust-bindgen 0.63.0 */
#![allow(nonstandard_style)]
pub type wchar_t = ::core::ffi::c_ushort;
pub type FILE = _iobuf;
pub type mwSize = usize;
pub type mwIndex = usize;
pub type mwSignedIndex = isize;
pub type CHAR16_T = wchar_t;
#[doc = " Forward declaration for mxArray"]
pub type mxArray = mxArray_tag;
#[doc = " MEX-file entry point type"]
pub type mxFunctionPtr = ::core::option::Option<
    unsafe extern "C" fn(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *mut mxArray,
    ),
>;
#[doc = " Logical type"]
pub type mxLogical = bool;
#[doc = " Required for Unicode support in MATLAB"]
pub type mxChar = CHAR16_T;
pub type mxClassID = ::core::ffi::c_int;
#[doc = " Indicates whether floating-point mxArrays are real or complex."]
pub type mxComplexity = ::core::ffi::c_int;
pub type mex_exit_fn = ::core::option::Option<unsafe extern "C" fn()>;
pub type mexGlobalTableEntry = mexGlobalTableEntry_Tag;
pub type mexGlobalTable = *mut mexGlobalTableEntry_Tag;
pub type mexFunctionTableEntry = mexFunctionTableEntry_tag;
pub type mexFunctionTable = *mut mexFunctionTableEntry_tag;
pub type mexLocalFunctionTable = *mut _mexLocalFunctionTable;
pub type mexInitTermTableEntry = *mut _mexInitTermTableEntry;
pub type fn_clean_up_after_error = ::core::option::Option<unsafe extern "C" fn()>;
pub type fn_simple_function_to_string =
    ::core::option::Option<unsafe extern "C" fn(f: mxFunctionPtr) -> *const ::core::ffi::c_char>;
pub type fn_mex_get_local_function_table =
    ::core::option::Option<unsafe extern "C" fn() -> mexLocalFunctionTable>;
pub type fn_mex_set_local_function_table = ::core::option::Option<
    unsafe extern "C" fn(arg1: mexLocalFunctionTable) -> mexLocalFunctionTable,
>;
pub type MATFile = MatFile_tag;
pub type matError = ::core::ffi::c_int;
pub type Engine = engine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxArray_tag {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mexGlobalTableEntry_Tag {
    pub name: *const ::core::ffi::c_char,
    pub variable: *mut *mut mxArray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mexFunctionTableEntry_tag {
    pub name: *const ::core::ffi::c_char,
    pub f: mxFunctionPtr,
    pub nargin: ::core::ffi::c_int,
    pub nargout: ::core::ffi::c_int,
    pub local_function_table: *mut _mexLocalFunctionTable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mexLocalFunctionTable {
    pub length: usize,
    pub entries: mexFunctionTable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mexInitTermTableEntry {
    pub initialize: ::core::option::Option<unsafe extern "C" fn()>,
    pub terminate: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatFile_tag {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine {
    _unused: [u8; 0],
}
pub const MWSIZE_MAX: u64 = 281474976710655;
pub const MWINDEX_MAX: u64 = 281474976710655;
pub const MWSINDEX_MAX: u64 = 281474976710655;
pub const MWSINDEX_MIN: i64 = -281474976710655;
pub const MWSIZE_MIN: u32 = 0;
pub const MWINDEX_MIN: u32 = 0;
pub const MW_FIRST_API_VERSION: u32 = 700;
pub const MW_LATEST_API_VERSION: u32 = 800;
pub const mxMAXNAM: u32 = 64;
pub const mxClassID_mxUNKNOWN_CLASS: mxClassID = 0;
pub const mxClassID_mxCELL_CLASS: mxClassID = 1;
pub const mxClassID_mxSTRUCT_CLASS: mxClassID = 2;
pub const mxClassID_mxLOGICAL_CLASS: mxClassID = 3;
pub const mxClassID_mxCHAR_CLASS: mxClassID = 4;
pub const mxClassID_mxVOID_CLASS: mxClassID = 5;
pub const mxClassID_mxDOUBLE_CLASS: mxClassID = 6;
pub const mxClassID_mxSINGLE_CLASS: mxClassID = 7;
pub const mxClassID_mxINT8_CLASS: mxClassID = 8;
pub const mxClassID_mxUINT8_CLASS: mxClassID = 9;
pub const mxClassID_mxINT16_CLASS: mxClassID = 10;
pub const mxClassID_mxUINT16_CLASS: mxClassID = 11;
pub const mxClassID_mxINT32_CLASS: mxClassID = 12;
pub const mxClassID_mxUINT32_CLASS: mxClassID = 13;
pub const mxClassID_mxINT64_CLASS: mxClassID = 14;
pub const mxClassID_mxUINT64_CLASS: mxClassID = 15;
pub const mxClassID_mxFUNCTION_CLASS: mxClassID = 16;
pub const mxClassID_mxOPAQUE_CLASS: mxClassID = 17;
pub const mxClassID_mxOBJECT_CLASS: mxClassID = 18;
pub const mxClassID_mxINDEX_CLASS: mxClassID = 15;
pub const mxComplexity_mxREAL: mxComplexity = 0;
pub const mxComplexity_mxCOMPLEX: mxComplexity = 1;
extern "C" {
    pub fn mxMalloc(n: usize) -> *mut ::core::ffi::c_void;
    pub fn mxCalloc(n: usize, size: usize) -> *mut ::core::ffi::c_void;
    pub fn mxFree(ptr: *mut ::core::ffi::c_void);
    pub fn mxRealloc(ptr: *mut ::core::ffi::c_void, size: usize) -> *mut ::core::ffi::c_void;
    pub fn mxGetNumberOfDimensions_730(pa: *const mxArray) -> mwSize;
    pub fn mxGetDimensions_730(pa: *const mxArray) -> *const mwSize;
    pub fn mxGetM(pa: *const mxArray) -> usize;
    pub fn mxGetIr_730(pa: *const mxArray) -> *mut mwIndex;
    pub fn mxGetJc_730(pa: *const mxArray) -> *mut mwIndex;
    pub fn mxGetNzmax_730(pa: *const mxArray) -> mwSize;
    pub fn mxSetNzmax_730(pa: *mut mxArray, nzmax: mwSize);
    pub fn mxGetFieldNameByNumber(
        pa: *const mxArray,
        n: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    pub fn mxGetFieldByNumber_730(
        pa: *const mxArray,
        i: mwIndex,
        fieldnum: ::core::ffi::c_int,
    ) -> *mut mxArray;
    pub fn mxGetCell_730(pa: *const mxArray, i: mwIndex) -> *mut mxArray;
    pub fn mxGetClassID(pa: *const mxArray) -> mxClassID;
    pub fn mxGetData(pa: *const mxArray) -> *mut ::core::ffi::c_void;
    pub fn mxSetData(pa: *mut mxArray, newdata: *mut ::core::ffi::c_void);
    pub fn mxIsNumeric(pa: *const mxArray) -> bool;
    pub fn mxIsCell(pa: *const mxArray) -> bool;
    pub fn mxIsLogical(pa: *const mxArray) -> bool;
    pub fn mxIsScalar(pa: *const mxArray) -> bool;
    pub fn mxIsChar(pa: *const mxArray) -> bool;
    pub fn mxIsStruct(pa: *const mxArray) -> bool;
    pub fn mxIsOpaque(pa: *const mxArray) -> bool;
    pub fn mxIsFunctionHandle(pa: *const mxArray) -> bool;
    pub fn mxIsObject(pa: *const mxArray) -> bool;
    pub fn mxGetImagData(pa: *const mxArray) -> *mut ::core::ffi::c_void;
    pub fn mxSetImagData(pa: *mut mxArray, newdata: *mut ::core::ffi::c_void);
    pub fn mxIsComplex(pa: *const mxArray) -> bool;
    pub fn mxIsSparse(pa: *const mxArray) -> bool;
    pub fn mxIsDouble(pa: *const mxArray) -> bool;
    pub fn mxIsSingle(pa: *const mxArray) -> bool;
    pub fn mxIsInt8(pa: *const mxArray) -> bool;
    pub fn mxIsUint8(pa: *const mxArray) -> bool;
    pub fn mxIsInt16(pa: *const mxArray) -> bool;
    pub fn mxIsUint16(pa: *const mxArray) -> bool;
    pub fn mxIsInt32(pa: *const mxArray) -> bool;
    pub fn mxIsUint32(pa: *const mxArray) -> bool;
    pub fn mxIsInt64(pa: *const mxArray) -> bool;
    pub fn mxIsUint64(pa: *const mxArray) -> bool;
    pub fn mxGetNumberOfElements(pa: *const mxArray) -> usize;
    pub fn mxGetPi(pa: *const mxArray) -> *mut f64;
    pub fn mxSetPi(pa: *mut mxArray, pi: *mut f64);
    pub fn mxGetChars(pa: *const mxArray) -> *mut mxChar;
    pub fn mxGetUserBits(pa: *const mxArray) -> ::core::ffi::c_int;
    pub fn mxSetUserBits(pa: *mut mxArray, value: ::core::ffi::c_int);
    pub fn mxGetScalar(pa: *const mxArray) -> f64;
    pub fn mxIsFromGlobalWS(pa: *const mxArray) -> bool;
    pub fn mxSetFromGlobalWS(pa: *mut mxArray, global: bool);
    pub fn mxSetM_730(pa: *mut mxArray, m: mwSize);
    pub fn mxGetN(pa: *const mxArray) -> usize;
    pub fn mxIsEmpty(pa: *const mxArray) -> bool;
    pub fn mxGetFieldNumber(
        pa: *const mxArray,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mxSetIr_730(pa: *mut mxArray, newir: *mut mwIndex);
    pub fn mxSetJc_730(pa: *mut mxArray, newjc: *mut mwIndex);
    pub fn mxGetPr(pa: *const mxArray) -> *mut f64;
    pub fn mxSetPr(pa: *mut mxArray, newdata: *mut f64);
    pub fn mxGetElementSize(pa: *const mxArray) -> usize;
    pub fn mxCalcSingleSubscript_730(
        pa: *const mxArray,
        nsubs: mwSize,
        subs: *const mwIndex,
    ) -> mwIndex;
    pub fn mxGetNumberOfFields(pa: *const mxArray) -> ::core::ffi::c_int;
    pub fn mxSetCell_730(pa: *mut mxArray, i: mwIndex, value: *mut mxArray);
    pub fn mxSetFieldByNumber_730(
        pa: *mut mxArray,
        i: mwIndex,
        fieldnum: ::core::ffi::c_int,
        value: *mut mxArray,
    );
    pub fn mxGetField_730(
        pa: *const mxArray,
        i: mwIndex,
        fieldname: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxSetField_730(
        pa: *mut mxArray,
        i: mwIndex,
        fieldname: *const ::core::ffi::c_char,
        value: *mut mxArray,
    );
    pub fn mxGetProperty_730(
        pa: *const mxArray,
        i: mwIndex,
        propname: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxSetProperty_730(
        pa: *mut mxArray,
        i: mwIndex,
        propname: *const ::core::ffi::c_char,
        value: *const mxArray,
    );
    pub fn mxGetClassName(pa: *const mxArray) -> *const ::core::ffi::c_char;
    pub fn mxIsClass(pa: *const mxArray, name: *const ::core::ffi::c_char) -> bool;
    pub fn mxCreateNumericMatrix_730(
        m: mwSize,
        n: mwSize,
        classid: mxClassID,
        flag: mxComplexity,
    ) -> *mut mxArray;
    pub fn mxCreateUninitNumericMatrix(
        m: usize,
        n: usize,
        classid: mxClassID,
        flag: mxComplexity,
    ) -> *mut mxArray;
    pub fn mxCreateUninitNumericArray(
        ndim: usize,
        dims: *mut usize,
        classid: mxClassID,
        flag: mxComplexity,
    ) -> *mut mxArray;
    pub fn mxSetN_730(pa: *mut mxArray, n: mwSize);
    pub fn mxSetDimensions_730(
        pa: *mut mxArray,
        pdims: *const mwSize,
        ndims: mwSize,
    ) -> ::core::ffi::c_int;
    pub fn mxDestroyArray(pa: *mut mxArray);
    pub fn mxCreateNumericArray_730(
        ndim: mwSize,
        dims: *const mwSize,
        classid: mxClassID,
        flag: mxComplexity,
    ) -> *mut mxArray;
    pub fn mxCreateCharArray_730(ndim: mwSize, dims: *const mwSize) -> *mut mxArray;
    pub fn mxCreateDoubleMatrix_730(m: mwSize, n: mwSize, flag: mxComplexity) -> *mut mxArray;
    pub fn mxGetLogicals(pa: *const mxArray) -> *mut mxLogical;
    pub fn mxCreateLogicalArray_730(ndim: mwSize, dims: *const mwSize) -> *mut mxArray;
    pub fn mxCreateLogicalMatrix_730(m: mwSize, n: mwSize) -> *mut mxArray;
    pub fn mxCreateLogicalScalar(value: bool) -> *mut mxArray;
    pub fn mxIsLogicalScalar(pa: *const mxArray) -> bool;
    pub fn mxIsLogicalScalarTrue(pa: *const mxArray) -> bool;
    pub fn mxCreateDoubleScalar(value: f64) -> *mut mxArray;
    pub fn mxCreateSparse_730(
        m: mwSize,
        n: mwSize,
        nzmax: mwSize,
        flag: mxComplexity,
    ) -> *mut mxArray;
    pub fn mxCreateSparseLogicalMatrix_730(m: mwSize, n: mwSize, nzmax: mwSize) -> *mut mxArray;
    pub fn mxGetNChars_730(pa: *const mxArray, buf: *mut ::core::ffi::c_char, nChars: mwSize);
    pub fn mxGetString_730(
        pa: *const mxArray,
        buf: *mut ::core::ffi::c_char,
        buflen: mwSize,
    ) -> ::core::ffi::c_int;
    pub fn mxArrayToString(pa: *const mxArray) -> *mut ::core::ffi::c_char;
    pub fn mxArrayToUTF8String(pa: *const mxArray) -> *mut ::core::ffi::c_char;
    pub fn mxCreateStringFromNChars_730(
        str_: *const ::core::ffi::c_char,
        n: mwSize,
    ) -> *mut mxArray;
    pub fn mxCreateString(str_: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn mxCreateCharMatrixFromStrings_730(
        m: mwSize,
        str_: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxCreateCellMatrix_730(m: mwSize, n: mwSize) -> *mut mxArray;
    pub fn mxCreateCellArray_730(ndim: mwSize, dims: *const mwSize) -> *mut mxArray;
    pub fn mxCreateStructMatrix_730(
        m: mwSize,
        n: mwSize,
        nfields: ::core::ffi::c_int,
        fieldnames: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxCreateStructArray_730(
        ndim: mwSize,
        dims: *const mwSize,
        nfields: ::core::ffi::c_int,
        fieldnames: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxDuplicateArray(in_: *const mxArray) -> *mut mxArray;
    pub fn mxSetClassName(
        pa: *mut mxArray,
        classname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mxAddField(
        pa: *mut mxArray,
        fieldname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mxRemoveField(pa: *mut mxArray, field: ::core::ffi::c_int);
    pub fn mxGetEps() -> f64;
    pub fn mxGetInf() -> f64;
    pub fn mxGetNaN() -> f64;
    pub fn mxIsFinite(x: f64) -> bool;
    pub fn mxIsInf(x: f64) -> bool;
    pub fn mxIsNaN(x: f64) -> bool;
    pub fn mxCreateSharedDataCopy(pa: *const mxArray) -> *mut mxArray;
    pub fn mxCreateUninitDoubleMatrix(
        cmplx_flag: ::core::ffi::c_int,
        m: usize,
        n: usize,
    ) -> *mut mxArray;
    pub fn mxFastZeros(
        cmplx_flag: ::core::ffi::c_int,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
    ) -> *mut mxArray;
    pub fn mxUnreference(pa: *mut mxArray) -> *mut mxArray;
    pub fn mxUnshareArray(pa: *mut mxArray, level: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn mxGetPropertyShared(
        pa: *const mxArray,
        i: usize,
        propname: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxSetPropertyShared(
        pa: *mut mxArray,
        i: usize,
        propname: *const ::core::ffi::c_char,
        value: *const mxArray,
    );
    pub fn mexErrMsgTxt(error_msg: *const ::core::ffi::c_char);
    pub fn mexErrMsgIdAndTxt(
        identifier: *const ::core::ffi::c_char,
        err_msg: *const ::core::ffi::c_char,
        ...
    );
    pub fn mexWarnMsgTxt(warn_msg: *const ::core::ffi::c_char);
    pub fn mexWarnMsgIdAndTxt(
        identifier: *const ::core::ffi::c_char,
        warn_msg: *const ::core::ffi::c_char,
        ...
    );
    pub fn mexPrintf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn mexMakeArrayPersistent(pa: *mut mxArray);
    pub fn mexMakeMemoryPersistent(ptr: *mut ::core::ffi::c_void);
    pub fn mexCallMATLABWithObject(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *mut mxArray,
        fcn_name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mexCallMATLABWithTrapWithObject(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *mut mxArray,
        fcn_name: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mexPrintAssertion(
        test: *const ::core::ffi::c_char,
        fname: *const ::core::ffi::c_char,
        linenum: ::core::ffi::c_int,
        message: *const ::core::ffi::c_char,
    );
    pub fn mexIsGlobal(pA: *const mxArray) -> bool;
    pub fn mexPutVariable(
        workspace: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        parray: *const mxArray,
    ) -> ::core::ffi::c_int;
    pub fn mexGetVariablePtr(
        workspace: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
    ) -> *const mxArray;
    pub fn mexGetVariableWithObject(
        workspace: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mexLock();
    pub fn mexUnlock();
    pub fn mexIsLocked() -> bool;
    pub fn mexFunctionName() -> *const ::core::ffi::c_char;
    pub fn mexEvalString(str_: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn mexEvalStringWithTrap(str_: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn mexAtExit(exit_fcn: mex_exit_fn) -> ::core::ffi::c_int;
    pub fn mexFunction(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *const mxArray,
    );
    pub fn matOpen(
        filename: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut MATFile;
    pub fn matClose(pMF: *mut MATFile) -> matError;
    pub fn matGetErrno(pMF: *mut MATFile) -> matError;
    pub fn matGetFp(pMF: *mut MATFile) -> *mut FILE;
    pub fn matPutVariable(
        pMF: *mut MATFile,
        name: *const ::core::ffi::c_char,
        pA: *const mxArray,
    ) -> matError;
    pub fn matPutVariableAsGlobal(
        pMF: *mut MATFile,
        name: *const ::core::ffi::c_char,
        pA: *const mxArray,
    ) -> matError;
    pub fn matGetVariable(pMF: *mut MATFile, name: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn matGetNextVariable(
        pMF: *mut MATFile,
        nameptr: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn matGetNextVariableInfo(
        pMF: *mut MATFile,
        nameptr: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn matGetVariableInfo(pMF: *mut MATFile, name: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn matDeleteVariable(pMF: *mut MATFile, name: *const ::core::ffi::c_char) -> matError;
    pub fn matGetDir(
        pMF: *mut MATFile,
        num: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    pub fn engEvalString(ep: *mut Engine, string: *const ::core::ffi::c_char)
        -> ::core::ffi::c_int;
    pub fn engOpenSingleUse(
        startcmd: *const ::core::ffi::c_char,
        reserved: *mut ::core::ffi::c_void,
        retstatus: *mut ::core::ffi::c_int,
    ) -> *mut Engine;
    pub fn engSetVisible(ep: *mut Engine, newVal: bool) -> ::core::ffi::c_int;
    pub fn engGetVisible(ep: *mut Engine, bVal: *mut bool) -> ::core::ffi::c_int;
    pub fn engOpen(startcmd: *const ::core::ffi::c_char) -> *mut Engine;
    pub fn engClose(ep: *mut Engine) -> ::core::ffi::c_int;
    pub fn engGetVariable(ep: *mut Engine, name: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn engPutVariable(
        ep: *mut Engine,
        var_name: *const ::core::ffi::c_char,
        ap: *const mxArray,
    ) -> ::core::ffi::c_int;
    pub fn engOutputBuffer(
        ep: *mut Engine,
        buffer: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}

/* automatically generated by rust-bindgen 0.63.0 */
#![allow(nonstandard_style)]
#[cfg(not(target_pointer_width = "64"))]
compile_error!("The bindings are only valid for 64-bit applications. All Matlab versions after 2015b are only available in 64-bit.");
pub type FILE = _iobuf;
pub type mwSize = usize;
pub type mwIndex = usize;
pub type mwSignedIndex = isize;
#[doc = " Forward declaration for mxArray"]
pub type mxArray = mxArray_tag;
#[doc = " MEX-file entry point type"]
pub type mxFunctionPtr = ::core::option::Option<
    unsafe extern "C" fn(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *mut mxArray,
    ),
>;
#[doc = " Logical type"]
pub type mxLogical = bool;
#[doc = " Required for Unicode support in MATLAB"]
pub type mxChar = u16;
pub type mex_exit_fn = ::core::option::Option<unsafe extern "C" fn()>;
pub type MATFile = MatFile_tag;
pub type matError = ::core::ffi::c_int;
pub type Engine = engine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxArray_tag {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatFile_tag {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine {
    _unused: [u8; 0],
}
pub const MWSIZE_MAX: u64 = 281474976710655;
pub const MWINDEX_MAX: u64 = 281474976710655;
pub const MWSINDEX_MAX: u64 = 281474976710655;
pub const MWSINDEX_MIN: i64 = -281474976710655;
pub const MWSIZE_MIN: u32 = 0;
pub const MWINDEX_MIN: u32 = 0;
pub const mxMAXNAM: u32 = 64;
pub mod mxClassID {
    #[doc = " mxArray classes."]
    pub type Type = i32;
    pub const mxUNKNOWN_CLASS: Type = 0;
    pub const mxCELL_CLASS: Type = 1;
    pub const mxSTRUCT_CLASS: Type = 2;
    pub const mxLOGICAL_CLASS: Type = 3;
    pub const mxCHAR_CLASS: Type = 4;
    pub const mxVOID_CLASS: Type = 5;
    pub const mxDOUBLE_CLASS: Type = 6;
    pub const mxSINGLE_CLASS: Type = 7;
    pub const mxINT8_CLASS: Type = 8;
    pub const mxUINT8_CLASS: Type = 9;
    pub const mxINT16_CLASS: Type = 10;
    pub const mxUINT16_CLASS: Type = 11;
    pub const mxINT32_CLASS: Type = 12;
    pub const mxUINT32_CLASS: Type = 13;
    pub const mxINT64_CLASS: Type = 14;
    pub const mxUINT64_CLASS: Type = 15;
    pub const mxFUNCTION_CLASS: Type = 16;
    pub const mxOPAQUE_CLASS: Type = 17;
    pub const mxOBJECT_CLASS: Type = 18;
    pub const mxINDEX_CLASS: Type = 15;
}
pub mod mxComplexity {
    #[doc = " Indicates whether floating-point mxArrays are real or complex."]
    pub type Type = i32;
    pub const mxREAL: Type = 0;
    pub const mxCOMPLEX: Type = 1;
}
extern "C" {
    pub fn mxMalloc(n: usize) -> *mut ::core::ffi::c_void;
    pub fn mxCalloc(n: usize, size: usize) -> *mut ::core::ffi::c_void;
    pub fn mxFree(ptr: *mut ::core::ffi::c_void);
    pub fn mxRealloc(ptr: *mut ::core::ffi::c_void, size: usize) -> *mut ::core::ffi::c_void;
    #[link_name = "\u{1}mxGetNumberOfDimensions_730"]
    pub fn mxGetNumberOfDimensions(pa: *const mxArray) -> mwSize;
    #[link_name = "\u{1}mxGetDimensions_730"]
    pub fn mxGetDimensions(pa: *const mxArray) -> *const mwSize;
    pub fn mxGetM(pa: *const mxArray) -> usize;
    #[link_name = "\u{1}mxGetIr_730"]
    pub fn mxGetIr(pa: *const mxArray) -> *mut mwIndex;
    #[link_name = "\u{1}mxGetJc_730"]
    pub fn mxGetJc(pa: *const mxArray) -> *mut mwIndex;
    #[link_name = "\u{1}mxGetNzmax_730"]
    pub fn mxGetNzmax(pa: *const mxArray) -> mwSize;
    #[link_name = "\u{1}mxSetNzmax_730"]
    pub fn mxSetNzmax(pa: *mut mxArray, nzmax: mwSize);
    pub fn mxGetFieldNameByNumber(
        pa: *const mxArray,
        n: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
    #[link_name = "\u{1}mxGetFieldByNumber_730"]
    pub fn mxGetFieldByNumber(
        pa: *const mxArray,
        i: mwIndex,
        fieldnum: ::core::ffi::c_int,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxGetCell_730"]
    pub fn mxGetCell(pa: *const mxArray, i: mwIndex) -> *mut mxArray;
    pub fn mxGetClassID(pa: *const mxArray) -> mxClassID::Type;
    pub fn mxGetData(pa: *const mxArray) -> *mut ::core::ffi::c_void;
    pub fn mxSetData(pa: *mut mxArray, newdata: *mut ::core::ffi::c_void);
    pub fn mxIsNumeric(pa: *const mxArray) -> bool;
    pub fn mxIsCell(pa: *const mxArray) -> bool;
    pub fn mxIsLogical(pa: *const mxArray) -> bool;
    pub fn mxIsScalar(pa: *const mxArray) -> bool;
    pub fn mxIsChar(pa: *const mxArray) -> bool;
    pub fn mxIsStruct(pa: *const mxArray) -> bool;
    pub fn mxIsOpaque(pa: *const mxArray) -> bool;
    pub fn mxIsFunctionHandle(pa: *const mxArray) -> bool;
    pub fn mxIsObject(pa: *const mxArray) -> bool;
    pub fn mxGetImagData(pa: *const mxArray) -> *mut ::core::ffi::c_void;
    pub fn mxSetImagData(pa: *mut mxArray, newdata: *mut ::core::ffi::c_void);
    pub fn mxIsComplex(pa: *const mxArray) -> bool;
    pub fn mxIsSparse(pa: *const mxArray) -> bool;
    pub fn mxIsDouble(pa: *const mxArray) -> bool;
    pub fn mxIsSingle(pa: *const mxArray) -> bool;
    pub fn mxIsInt8(pa: *const mxArray) -> bool;
    pub fn mxIsUint8(pa: *const mxArray) -> bool;
    pub fn mxIsInt16(pa: *const mxArray) -> bool;
    pub fn mxIsUint16(pa: *const mxArray) -> bool;
    pub fn mxIsInt32(pa: *const mxArray) -> bool;
    pub fn mxIsUint32(pa: *const mxArray) -> bool;
    pub fn mxIsInt64(pa: *const mxArray) -> bool;
    pub fn mxIsUint64(pa: *const mxArray) -> bool;
    pub fn mxGetNumberOfElements(pa: *const mxArray) -> usize;
    pub fn mxGetPi(pa: *const mxArray) -> *mut f64;
    pub fn mxSetPi(pa: *mut mxArray, pi: *mut f64);
    pub fn mxGetChars(pa: *const mxArray) -> *mut mxChar;
    pub fn mxGetUserBits(pa: *const mxArray) -> ::core::ffi::c_int;
    pub fn mxSetUserBits(pa: *mut mxArray, value: ::core::ffi::c_int);
    pub fn mxGetScalar(pa: *const mxArray) -> f64;
    pub fn mxIsFromGlobalWS(pa: *const mxArray) -> bool;
    pub fn mxSetFromGlobalWS(pa: *mut mxArray, global: bool);
    #[link_name = "\u{1}mxSetM_730"]
    pub fn mxSetM(pa: *mut mxArray, m: mwSize);
    pub fn mxGetN(pa: *const mxArray) -> usize;
    pub fn mxIsEmpty(pa: *const mxArray) -> bool;
    pub fn mxGetFieldNumber(
        pa: *const mxArray,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}mxSetIr_730"]
    pub fn mxSetIr(pa: *mut mxArray, newir: *mut mwIndex);
    #[link_name = "\u{1}mxSetJc_730"]
    pub fn mxSetJc(pa: *mut mxArray, newjc: *mut mwIndex);
    pub fn mxGetPr(pa: *const mxArray) -> *mut f64;
    pub fn mxSetPr(pa: *mut mxArray, newdata: *mut f64);
    pub fn mxGetElementSize(pa: *const mxArray) -> usize;
    #[link_name = "\u{1}mxCalcSingleSubscript_730"]
    pub fn mxCalcSingleSubscript(
        pa: *const mxArray,
        nsubs: mwSize,
        subs: *const mwIndex,
    ) -> mwIndex;
    pub fn mxGetNumberOfFields(pa: *const mxArray) -> ::core::ffi::c_int;
    #[link_name = "\u{1}mxSetCell_730"]
    pub fn mxSetCell(pa: *mut mxArray, i: mwIndex, value: *mut mxArray);
    #[link_name = "\u{1}mxSetFieldByNumber_730"]
    pub fn mxSetFieldByNumber(
        pa: *mut mxArray,
        i: mwIndex,
        fieldnum: ::core::ffi::c_int,
        value: *mut mxArray,
    );
    #[link_name = "\u{1}mxGetField_730"]
    pub fn mxGetField(
        pa: *const mxArray,
        i: mwIndex,
        fieldname: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxSetField_730"]
    pub fn mxSetField(
        pa: *mut mxArray,
        i: mwIndex,
        fieldname: *const ::core::ffi::c_char,
        value: *mut mxArray,
    );
    #[link_name = "\u{1}mxGetProperty_730"]
    pub fn mxGetProperty(
        pa: *const mxArray,
        i: mwIndex,
        propname: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxSetProperty_730"]
    pub fn mxSetProperty(
        pa: *mut mxArray,
        i: mwIndex,
        propname: *const ::core::ffi::c_char,
        value: *const mxArray,
    );
    pub fn mxGetClassName(pa: *const mxArray) -> *const ::core::ffi::c_char;
    pub fn mxIsClass(pa: *const mxArray, name: *const ::core::ffi::c_char) -> bool;
    #[link_name = "\u{1}mxCreateNumericMatrix_730"]
    pub fn mxCreateNumericMatrix(
        m: mwSize,
        n: mwSize,
        classid: mxClassID::Type,
        flag: mxComplexity::Type,
    ) -> *mut mxArray;
    pub fn mxCreateUninitNumericMatrix(
        m: usize,
        n: usize,
        classid: mxClassID::Type,
        flag: mxComplexity::Type,
    ) -> *mut mxArray;
    pub fn mxCreateUninitNumericArray(
        ndim: usize,
        dims: *mut usize,
        classid: mxClassID::Type,
        flag: mxComplexity::Type,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxSetN_730"]
    pub fn mxSetN(pa: *mut mxArray, n: mwSize);
    #[link_name = "\u{1}mxSetDimensions_730"]
    pub fn mxSetDimensions(
        pa: *mut mxArray,
        pdims: *const mwSize,
        ndims: mwSize,
    ) -> ::core::ffi::c_int;
    pub fn mxDestroyArray(pa: *mut mxArray);
    #[link_name = "\u{1}mxCreateNumericArray_730"]
    pub fn mxCreateNumericArray(
        ndim: mwSize,
        dims: *const mwSize,
        classid: mxClassID::Type,
        flag: mxComplexity::Type,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateCharArray_730"]
    pub fn mxCreateCharArray(ndim: mwSize, dims: *const mwSize) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateDoubleMatrix_730"]
    pub fn mxCreateDoubleMatrix(m: mwSize, n: mwSize, flag: mxComplexity::Type) -> *mut mxArray;
    pub fn mxGetLogicals(pa: *const mxArray) -> *mut mxLogical;
    #[link_name = "\u{1}mxCreateLogicalArray_730"]
    pub fn mxCreateLogicalArray(ndim: mwSize, dims: *const mwSize) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateLogicalMatrix_730"]
    pub fn mxCreateLogicalMatrix(m: mwSize, n: mwSize) -> *mut mxArray;
    pub fn mxCreateLogicalScalar(value: bool) -> *mut mxArray;
    pub fn mxIsLogicalScalar(pa: *const mxArray) -> bool;
    pub fn mxIsLogicalScalarTrue(pa: *const mxArray) -> bool;
    pub fn mxCreateDoubleScalar(value: f64) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateSparse_730"]
    pub fn mxCreateSparse(
        m: mwSize,
        n: mwSize,
        nzmax: mwSize,
        flag: mxComplexity::Type,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateSparseLogicalMatrix_730"]
    pub fn mxCreateSparseLogicalMatrix(m: mwSize, n: mwSize, nzmax: mwSize) -> *mut mxArray;
    #[link_name = "\u{1}mxGetNChars_730"]
    pub fn mxGetNChars(pa: *const mxArray, buf: *mut ::core::ffi::c_char, nChars: mwSize);
    #[link_name = "\u{1}mxGetString_730"]
    pub fn mxGetString(
        pa: *const mxArray,
        buf: *mut ::core::ffi::c_char,
        buflen: mwSize,
    ) -> ::core::ffi::c_int;
    pub fn mxArrayToString(pa: *const mxArray) -> *mut ::core::ffi::c_char;
    pub fn mxArrayToUTF8String(pa: *const mxArray) -> *mut ::core::ffi::c_char;
    #[link_name = "\u{1}mxCreateStringFromNChars_730"]
    pub fn mxCreateStringFromNChars(str_: *const ::core::ffi::c_char, n: mwSize) -> *mut mxArray;
    pub fn mxCreateString(str_: *const ::core::ffi::c_char) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateCharMatrixFromStrings_730"]
    pub fn mxCreateCharMatrixFromStrings(
        m: mwSize,
        str_: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateCellMatrix_730"]
    pub fn mxCreateCellMatrix(m: mwSize, n: mwSize) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateCellArray_730"]
    pub fn mxCreateCellArray(ndim: mwSize, dims: *const mwSize) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateStructMatrix_730"]
    pub fn mxCreateStructMatrix(
        m: mwSize,
        n: mwSize,
        nfields: ::core::ffi::c_int,
        fieldnames: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    #[link_name = "\u{1}mxCreateStructArray_730"]
    pub fn mxCreateStructArray(
        ndim: mwSize,
        dims: *const mwSize,
        nfields: ::core::ffi::c_int,
        fieldnames: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxDuplicateArray(in_: *const mxArray) -> *mut mxArray;
    pub fn mxSetClassName(
        pa: *mut mxArray,
        classname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mxAddField(
        pa: *mut mxArray,
        fieldname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mxRemoveField(pa: *mut mxArray, field: ::core::ffi::c_int);
    pub fn mxGetEps() -> f64;
    pub fn mxGetInf() -> f64;
    pub fn mxGetNaN() -> f64;
    pub fn mxIsFinite(x: f64) -> bool;
    pub fn mxIsInf(x: f64) -> bool;
    pub fn mxIsNaN(x: f64) -> bool;
    pub fn mxCreateSharedDataCopy(pa: *const mxArray) -> *mut mxArray;
    pub fn mxCreateUninitDoubleMatrix(
        cmplx_flag: ::core::ffi::c_int,
        m: usize,
        n: usize,
    ) -> *mut mxArray;
    pub fn mxFastZeros(
        cmplx_flag: ::core::ffi::c_int,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
    ) -> *mut mxArray;
    pub fn mxUnreference(pa: *mut mxArray) -> *mut mxArray;
    pub fn mxUnshareArray(pa: *mut mxArray, level: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn mxGetPropertyShared(
        pa: *const mxArray,
        i: usize,
        propname: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mxSetPropertyShared(
        pa: *mut mxArray,
        i: usize,
        propname: *const ::core::ffi::c_char,
        value: *const mxArray,
    );
    pub fn mexErrMsgTxt(error_msg: *const ::core::ffi::c_char);
    pub fn mexErrMsgIdAndTxt(
        identifier: *const ::core::ffi::c_char,
        err_msg: *const ::core::ffi::c_char,
        ...
    );
    pub fn mexWarnMsgTxt(warn_msg: *const ::core::ffi::c_char);
    pub fn mexWarnMsgIdAndTxt(
        identifier: *const ::core::ffi::c_char,
        warn_msg: *const ::core::ffi::c_char,
        ...
    );
    pub fn mexPrintf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn mexMakeArrayPersistent(pa: *mut mxArray);
    pub fn mexMakeMemoryPersistent(ptr: *mut ::core::ffi::c_void);
    pub fn mexCallMATLABWithObject(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *mut mxArray,
        fcn_name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn mexCallMATLABWithTrapWithObject(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *mut mxArray,
        fcn_name: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mexPrintAssertion(
        test: *const ::core::ffi::c_char,
        fname: *const ::core::ffi::c_char,
        linenum: ::core::ffi::c_int,
        message: *const ::core::ffi::c_char,
    );
    pub fn mexIsGlobal(pA: *const mxArray) -> bool;
    pub fn mexPutVariable(
        workspace: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        parray: *const mxArray,
    ) -> ::core::ffi::c_int;
    pub fn mexGetVariablePtr(
        workspace: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
    ) -> *const mxArray;
    pub fn mexGetVariableWithObject(
        workspace: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn mexLock();
    pub fn mexUnlock();
    pub fn mexIsLocked() -> bool;
    pub fn mexFunctionName() -> *const ::core::ffi::c_char;
    pub fn mexEvalString(str_: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn mexEvalStringWithTrap(str_: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn mexAtExit(exit_fcn: mex_exit_fn) -> ::core::ffi::c_int;
    pub fn mexFunction(
        nlhs: ::core::ffi::c_int,
        plhs: *mut *mut mxArray,
        nrhs: ::core::ffi::c_int,
        prhs: *mut *const mxArray,
    );
    pub fn matOpen(
        filename: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut MATFile;
    pub fn matClose(pMF: *mut MATFile) -> matError;
    pub fn matGetErrno(pMF: *mut MATFile) -> matError;
    pub fn matGetFp(pMF: *mut MATFile) -> *mut FILE;
    pub fn matPutVariable(
        pMF: *mut MATFile,
        name: *const ::core::ffi::c_char,
        pA: *const mxArray,
    ) -> matError;
    pub fn matPutVariableAsGlobal(
        pMF: *mut MATFile,
        name: *const ::core::ffi::c_char,
        pA: *const mxArray,
    ) -> matError;
    pub fn matGetVariable(pMF: *mut MATFile, name: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn matGetNextVariable(
        pMF: *mut MATFile,
        nameptr: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn matGetNextVariableInfo(
        pMF: *mut MATFile,
        nameptr: *mut *const ::core::ffi::c_char,
    ) -> *mut mxArray;
    pub fn matGetVariableInfo(pMF: *mut MATFile, name: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn matDeleteVariable(pMF: *mut MATFile, name: *const ::core::ffi::c_char) -> matError;
    pub fn matGetDir(
        pMF: *mut MATFile,
        num: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    pub fn engEvalString(ep: *mut Engine, string: *const ::core::ffi::c_char)
        -> ::core::ffi::c_int;
    pub fn engOpenSingleUse(
        startcmd: *const ::core::ffi::c_char,
        reserved: *mut ::core::ffi::c_void,
        retstatus: *mut ::core::ffi::c_int,
    ) -> *mut Engine;
    pub fn engSetVisible(ep: *mut Engine, newVal: bool) -> ::core::ffi::c_int;
    pub fn engGetVisible(ep: *mut Engine, bVal: *mut bool) -> ::core::ffi::c_int;
    pub fn engOpen(startcmd: *const ::core::ffi::c_char) -> *mut Engine;
    pub fn engClose(ep: *mut Engine) -> ::core::ffi::c_int;
    pub fn engGetVariable(ep: *mut Engine, name: *const ::core::ffi::c_char) -> *mut mxArray;
    pub fn engPutVariable(
        ep: *mut Engine,
        var_name: *const ::core::ffi::c_char,
        ap: *const mxArray,
    ) -> ::core::ffi::c_int;
    pub fn engOutputBuffer(
        ep: *mut Engine,
        buffer: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
